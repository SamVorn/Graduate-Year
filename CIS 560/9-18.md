L2 = {w | w contains substring 011}
 
 -> 0 -> 1 -> 1 ->
 ## Rules of NFA and DFA
```
 DFA is a special case of NFA
 ```
 ```
 Every DFA is automatically an NFA
 ```
 ```
 Every NFA has an equivalent DFA
 ```
Denoted in Theorem 1.39, Page 55

If you have n states with n = |Q|
Then |P(Q)| = 2^n

```
A language is regular if and only if some NFA recognizes it
```
```
Forward: A language is regular => some NFA recognizes it
Backward: if some NFA recognizes a language => A is regular
```
```
Forward: if a language is regular => some DFA recognizes it
a DFA is automatically an NFA => some NFA recognizes it
Backward: if some NFA N recognizes language A => since every NFA has an equivalent DFA there exists a DFA D such that L(N) = L(D)
=> By definition A is regular
```

```
Let A1 and A2 be regular => A1 Union A2 is also regular (Proof?)
there is an NFA for A1 and A2
Combine the two with a new start state in an NFA
If both of the combined machines reject the string then it is not part of the regular language.
```
```
Let A1 and A2 be regular languages
Prove A1 * A2 is regular (concatenation)
Change the final states of NFA1 to the start states of NFA2
- epsilon transition
- nonfinal
```
```
A is regular => A* is regular
N1 exists
N2 must have a new start state that is a also a final state
- new start state, make it final
- epsilon transition
- introduce epsilon transition from the final state to the original start state
```
```
Regular Expression R describes L(R)
R = (0 U 1)0*
W starts with 0 or 1 followed by any number of 0's
```
